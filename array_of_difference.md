
## 问题背景
假设有一个由`n`个数字组成的数组`A`, 接下来我们会对数组做多次区间修改操作。区间修改操作指的是对某个区间`[i,j]`内的所有元素做同一加减运算，比如对区间[3,5]做加5的运算, 指的就是`A[3],A[4],A[5]`在原来的值的基础上均加上5。

最朴素的做法就是每次区间修改操作都落实到每个元素上，在区间内逐个元素做运算。假设区间长度为`N`，逐元素操作的时间复杂度就是`O(N)`。如果一共进行`M`次区间修改操作，那么总时间复杂度就是`O(MN)`，平方级的复杂度，放到一些对时间要求比较严格的场景可能就不适用了。

那么有没有更高效的办法呢？这就要说到今天的主角——差分数组了。
## 差分数组
差分(Difference)，简单来说，就是用当前数值减去上一个数值,也即当前数值相对上一个数值的变化情况。
比如`A[5]`对应的差分`Diff[5]`就是`D[5]=A[5]-A[4]`。

针对上面的区间操作，我们不难发现这么一个性质：因为区间操作对区间内的元素做的是同一种加减操作,所以区间内的元素的相对关系并没有发生变化。

比如对区间`[3,5]`做+5的区间操作,虽然`A[3], A[4], A[5]`都加了5，但`D'[5] = (A[5]+5) - (A[4]+5) = D[5]`, 没有发生改变。差分值仅当数组A的前后两个元素不同时发生相同变化时才会改变。回到这个例子中,发生改变的是区间`[3,5]`的头部`D'[3] = A[3] + 5 - A[2] = D[3] + 5`和区间尾部的后一个元素`D'[6] = A[6] - (A[5] + 5) = D[6] - 5`。

更通用地来说,假设对区间`[i,j]`做`+k`的区间操作, 反映到差分数组D上,只需要修改两项：`D[i]+=k`, `D[j+1]-=k`,时间复杂度从`O(N)`降低到`O(1)`。


## 还原原数组
通过差分数组，我们把原来区间长度`N`的区间操作的时间复杂度降低为`O(1)`。那么应该如何根据差分数组还原原数组呢？

利用前缀和。

以还原`A[5]`为例
```
D[5] = A[5] - A[4], 因此A[5] = D[5] + A[4]
D[4] = A[4] - A[3], 因此A[4] = D[4] + A[3]
...
D[1] = A[1] - A[0], 因此A[1] = D[1] + A[0]

把中间的A[i]项都用右侧的表达式替换,可以得到
A[5] = D[5] + D[4] + D[3] + D[2] + D[1] + A[0]
因为数组第0项前面没有元素, 我们定义D[0] = A[0]
那么A[5] = D[5] + D[4] + D[3] + D[2] + D[1] + D[0]
其实就是差分数组的前面各项之和,也即前缀和
```
遍历一遍差分数组，就可以计算出每一项的前缀和,因此时间复杂度是`O(N)`

因此对数组A做M次区间操作，利用差分数组，我们可以将时间复杂度从`O(MN)`降低到`O(M+N)`



定义:
```
对于有n个元素组成的数组A, 我们可以建立一个记录数组A的每一项与前一项差值的差分数组D.
对于i = 0, 定义D[0] = A[0]
对于i >= 1,有`D[i] = A[i] - A[i-1]

```


性质：
```
1.
假设对数组A的区间[i,j]做+k的区间操作, 反映到差分数组D上,只需要修改两项：
第一个受区间操作影响的元素的差分项：D[i]+=k
最后一个受区间操作影响元素的下一个元素的差分项：D[j+1]-=k

2.
定义差分数组D的前缀和数组为preSum
定义preSum[0] = 0
当i >= 0时, preSum[i+1] = preSum[i] + D[i]
由前缀和可求原数组的元素项A[i] = preSum[i+1]

3.
单次区间操作修改差分数组的时间复杂度:O(1)
区间操作完毕恢复原数组的时间复杂度:O(N)

```
